- [1. 常见的数据结构](#1-常见的数据结构)
- [2. 数据结构的选择](#2-数据结构的选择)
- [3. 数组(Array)](#3-数组array)
- [4. 链表(LinkedList)](#4-链表linkedlist)



按逻辑结构分类：

- 集合（无逻辑关系）
- 线性结构（线性表）
  1. 一维数组
  2. 队列
  3. 栈
- 非线性结构
  1. 树
  2. 图
  3. 多维数组

按存储结构分类：

- 顺序存储结构
- 链式存储结构
- 索引存储结构
- 散列存储结构

每种逻辑结构采用何种物理结构来实现，并没有具体的规定。当一个结构，在逻辑结构中只有一种定义，而在物理结构中却有两种定义，那么这个结构就属于逻辑结构；

**数据结构的比较**

| **数据结构** |                          **优点**                          |                       **缺点**                       |
| :----------: | :--------------------------------------------------------: | :--------------------------------------------------: |
|     数组     |                           插入快                           |     查找慢，删除慢，大小固定，只能存储的那一元素     |
|   有序数组   |                      比无序数组查询快                      |      插入慢，删除慢，大小固定，只能存储单一元素      |
|      栈      |                   提供先进先出的存取方式                   |                    存储其它项很慢                    |
|     队列     |                   提供先进先出的存取方式                   |                    存取其它项很慢                    |
|     链表     |                       插入快，删除快                       |                        查找慢                        |
|    二叉树    |           如果树是平衡的，则查找，插入，删除都快           |                     删除算法复杂                     |
|    红黑树    | 查找，插入，删除都快。树总是平衡的，类似的树对磁盘存储有效 |                       算法复杂                       |
|   2-3-4 树   | 查找，插入，删除都快。树总是平衡的，类似的树对磁盘存储有效 |                       算法复杂                       |
|    哈希表    |                  如果关键字已知则存取极快                  | 删除慢，如果不知道关键字存取慢，对存储空间使用不充分 |
|      堆      |              插入，删除快，对最大数据项存取快              |                  对其它数据项存取慢                  |
|      图      |                       对现实世界建模                       |                   有些算法慢且复杂                   |

#### 1. 常见的数据结构

- 队列（Queue）
- 树（Tree）
- 堆（Heap）
- 数组（Array）
- 栈（Stack）
- 链表（LinkedList）
- 图（Graph）
- 散列表-哈希表（Hash）

#### 2. 数据结构的选择

![数据结构的选择](/img/2.png)

#### 3. 数组(Array)

在Java中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型。

```java
// 只声明了类型和长度
数据类型[] 数组名称 = new 数据类型[数组长度];
// 声明了类型，初始化赋值，大小由元素个数决定
数据类型[] 数组名称 = {元素1, 元素2, ....};
// 缺点：大小固定，不能动态扩展(初始化给大了，浪费；给小了，不够用)，插入快，删除和查找慢
```

模拟实现：

```java
public class Array
{
    private int[] intArray;
    private int length;
    private int elems;

    public Array(int max) {
        length = max;
        intArray = new int[max];
        elems = 0;
    }

    /**
     * 添加
     * @param value
     */
    public void add(int value) {
        if (elems == length) {
            System.out.println("error");
            return;
        }
        intArray[elems] = value;
        elems++;
    }

    /**
     * 查找
     * @param searchKey
     * @return
     */
    public int find(int searchKey) {
        int i;
        for (i = 0; i < elems; i++) {
            if (intArray[i] == searchKey) {
                break;
            }
        }
        if (i == elems) {
            return -1;
        }
        return i;
    }

    /**
     * 更新(修改)
     * @param oldValue
     * @param newValue
     * @return
     */
    public boolean update(int oldValue, int newValue) {
        int i = find(oldValue);
        if (i == -1) {
            return false;
        }
        intArray[i] = newValue;
        return true;
    }

    /**
     * 删除
     * @param value
     * @return
     */
    public boolean delete(int value) {
        int i = find(value);
        if (i == -1) {
            return false;
        }
        for (int j = i; i < elems - 1; j++) {
            // 后面的数据往前移
            intArray[j] = intArray[j + 1];
        }
        elems--;
        return true;
    }

    /**
     * 显示所有
     */
    public void display() {
        for (int i = 0; i < elems; i++) {
            System.out.println(intArray[i] + " ");
        }
        System.out.println("\n");
    }
}
```

#### 4. 链表(LinkedList)

- 链表即是由节点组成的线性集合，每个节点可以利用指针指向其他节点。它是一种包含了多个节点的、能够用于表示序列的数据结构
- `单向链表`：链表中的节点仅指向下一个节点，并且最后一个节点指向空
- `双向链表`：其中每个节点具有两个指针p、n，使得p指向先前节点并且n之前下一节点；最后一个节点的n指针指向null
- `循环链表`：每个节点指向下一节点并且最后一个节点指向第一个节点的链表

```java
public class LinkedList
{

    // 链表头
    private Node head;
    // 链表尾
    private Node tail;
    // 节点数
    private int size;

    public static void main(String[] args) {
        LinkedList linkedlist = new LinkedList();
        linkedlist.addHead("456");
        linkedlist.addHead("123");
        //linkedlist.addTail("hello ");
        //linkedlist.addTail("word");
        //linkedlist.deleteHead();
        //linkedlist.deleteTail();
        linkedlist.display();
    }    

    /**
     * 双端链表
     */
    public class Node {
        private Object data;
        // 上一个
        private Node prev;
        // 下一个
        private Node next;

        public Node(Object data) {
            this.data = data;
        }
    }

    public LinkedList() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }

    /**
     * 向链表头添加数据
     * @param object
     */
    public void addHead(Object object) {
        Node node = new Node(object);
        if (size == 0) {
            head = node;
            tail = node;
            size++;
        } else {
            head.prev = node;
            node.next = head;
            head = node;
            size++;
        }
    }

    /**
     * 删除头
     */
    public void deleteHead() {
        // 头部指向下一个，prev值为空则说明是链表的头部
        if (size != 0) {
            head.prev = null;
            head = head.next;
            size--;
        }
    }

    /**
     * 向链表尾部添加数据
     */
    public void addTail(Object object) {
        Node node = new Node(object);
        if (size == 0) {
            head = node;
            tail = node;
            size++;
        } else {
            node.prev = tail;
            tail.next = node;
            tail = node;
            size++;
        }
    }

    /**
     * 删除尾部
     */
    public void deleteTail() {
        // 尾部指向上一个，next值为null则说明是链表的尾部
        if (size != 0) {
            tail.next = null;
            tail = tail.prev;
            size--;
        }
    }

    /**
     * 显示数据
     */
    public void display() {

        if (size > 0) {
            Node node = head;
            int tempSize = size;
            if (tempSize == 1) {
                System.out.println("["+node.data+"]");
                return;
            }

            while (tempSize > 0) {
                if (node.equals(head)) {
                    System.out.print("["+node.data+"->");
                } else if (node.next == null) {
                    System.out.print(node.data+"]");
                } else {
                    System.out.print(node.data+"->");
                }
                node = node.next;
                tempSize--;
            }
        }
    }
}
```

#### 5. 队列(Queue)

- 队列是元素的集合，其包含了两个基本操作：enqueue操作可以用于将元素插入到队列中，而dequeue操作则是将元素从队列中删除
- 咨询先入先出的原则(FIFO)

