- [1. 常见的数据结构](#1-常见的数据结构)
- [2. 数据结构的选择](#2-数据结构的选择)



按逻辑结构分类：

- 集合（无逻辑关系）
- 线性结构（线性表）
  1. 一维数组
  2. 队列
  3. 栈
- 非线性结构
  1. 树
  2. 图
  3. 多维数组

按存储结构分类：

- 顺序存储结构
- 链式存储结构
- 索引存储结构
- 散列存储结构

每种逻辑结构采用何种物理结构来实现，并没有具体的规定。当一个结构，在逻辑结构中只有一种定义，而在物理结构中却有两种定义，那么这个结构就属于逻辑结构；

**数据结构的比较**

| **数据结构** |                          **优点**                          |                       **缺点**                       |
| :----------: | :--------------------------------------------------------: | :--------------------------------------------------: |
|     数组     |                           插入快                           |     查找慢，删除慢，大小固定，只能存储的那一元素     |
|   有序数组   |                      比无序数组查询快                      |      插入慢，删除慢，大小固定，只能存储单一元素      |
|      栈      |                   提供先进先出的存取方式                   |                    存储其它项很慢                    |
|     队列     |                   提供先进先出的存取方式                   |                    存取其它项很慢                    |
|     链表     |                       插入快，删除快                       |                        查找慢                        |
|    二叉树    |           如果树是平衡的，则查找，插入，删除都快           |                     删除算法复杂                     |
|    红黑树    | 查找，插入，删除都快。树总是平衡的，类似的树对磁盘存储有效 |                       算法复杂                       |
|   2-3-4 树   | 查找，插入，删除都快。树总是平衡的，类似的树对磁盘存储有效 |                       算法复杂                       |
|    哈希表    |                  如果关键字已知则存取极快                  | 删除慢，如果不知道关键字存取慢，对存储空间使用不充分 |
|      堆      |              插入，删除快，对最大数据项存取快              |                  对其它数据项存取慢                  |
|      图      |                       对现实世界建模                       |                   有些算法慢且复杂                   |

#### 1. 常见的数据结构

- 队列（Queue）
- 树（Tree）
- 堆（Heap）
- 数组（Array）
- 栈（Stack）
- 链表（LinkedList）
- 图（Graph）
- 散列表-哈希表（Hash）

#### 2. 数据结构的选择

![数据结构的选择](/img/2.png)

#### 3. 数组(Array)

在Java中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型。

```java
// 只声明了类型和长度
数据类型[] 数组名称 = new 数据类型[数组长度];
// 声明了类型，初始化赋值，大小由元素个数决定
数据类型[] 数组名称 = {元素1, 元素2, ....};
// 缺点：大小固定，不能动态扩展(初始化给大了，浪费；给小了，不够用)，插入快，删除和查找慢
```

模拟实现：

```java
public class Array
{
    private int[] intArray;
    private int length;
    private int elems;

    public Array(int max) {
        length = max;
        intArray = new int[max];
        elems = 0;
    }

    /**
     * 添加
     * @param value
     */
    public void add(int value) {
        if (elems == length) {
            System.out.println("error");
            return;
        }
        intArray[elems] = value;
        elems++;
    }

    /**
     * 查找
     * @param searchKey
     * @return
     */
    public int find(int searchKey) {
        int i;
        for (i = 0; i < elems; i++) {
            if (intArray[i] == searchKey) {
                break;
            }
        }
        if (i == elems) {
            return -1;
        }
        return i;
    }

    /**
     * 更新(修改)
     * @param oldValue
     * @param newValue
     * @return
     */
    public boolean update(int oldValue, int newValue) {
        int i = find(oldValue);
        if (i == -1) {
            return false;
        }
        intArray[i] = newValue;
        return true;
    }

    /**
     * 删除
     * @param value
     * @return
     */
    public boolean delete(int value) {
        int i = find(value);
        if (i == -1) {
            return false;
        }
        for (int j = i; i < elems - 1; j++) {
            // 后面的数据往前移
            intArray[j] = intArray[j + 1];
        }
        elems--;
        return true;
    }

    /**
     * 显示所有
     */
    public void display() {
        for (int i = 0; i < elems - 1; i++) {
            System.out.println(intArray[i] + " ");
        }
        System.out.println("\n");
    }
}
```

